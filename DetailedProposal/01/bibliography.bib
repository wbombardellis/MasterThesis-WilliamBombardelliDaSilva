@article{anjorin201620,
  title={20 Years of Triple Graph Grammars: A Roadmap for Future Research},
  author={Anjorin, Anthony and Leblebici, Erhan and Sch{\"u}rr, Andy},
  journal={Electronic Communications of the EASST},
  volume={73},
  year={2016}
}
@article{Rozenberg1986,
	abstract = {Node label controlled (NLC) grammars are graph grammars (operating on node labeled undirected graphs) which rewrite single nodes only and establish connections between the embedded graph and the neighbors of the rewritten node on the basis of the labels of the involved nodes only. They define (possibly infinite) languages of undirected node labeled graphs (or, if we just omit the labels, languages of unlabeled graphs). Here we consider a restriction of NLC grammars, so-called boundary NLC (BNLC) grammars, distinguished by the property that whenever in a graph already generated two nodes may be rewritten, then these nodes are not adjacent. The graph languages generated by this type of grammars are called BNLC languages. Although we show that this restriction leads to a smaller class of languages, still enough generative power remains to define interesting graph languages. For example, trees, complete bipartite graphs, maximal outerplanar graphs, k-trees, graphs of bandwidth ≤k, graphs of cyclic bandwidth ≤k, graphs of binary tree bandwidth ≤k, graphs of cutwidth ≤k (always for a fixed positive integer k) turn out all to be BNLC languages. We prove a number of normal forms for BNLC grammars and then we indicate their usefulness by various applications. In particular, we show that for connected graphs of bounded degree the membership problem for BNLC languages is solvable in deterministic polynomial time. {\textcopyright} 1986 Academic Press, Inc.},
	author = {Rozenberg, Grzegorz and Welzl, Emo},
	doi = {10.1016/S0019-9958(86)80045-6},
	file = {:media/dados/2018-1/MasterThesis/Papers/27{\_}BoundaryNLCGG.pdf:pdf},
	issn = {00199958},
	journal = {Information and Control},
	number = {1-3},
	pages = {136--167},
	title = {{Boundary NLC graph grammars-Basic definitions, normal forms, and complexity}},
	volume = {69},
	year = {1986}
}
@article{Flasinski2014,
	author = {Flasi{\'{n}}ski, M and Flasi{\'{n}}ska, Z},
	file = {:media/dados/2018-1/MasterThesis/Papers/Search/65{\_}TopDown{\_}edNLC{\_}978-3-319-11331-9{\_}24.pdf:pdf},
	issn = {16113349},
	journal = {Computer Vision and Graphics},
	pages = {195--202},
	title = {{Characteristics of Bottom-Up Parsable edNLC Graph Languages for Syntactic Pattern Recognition}},
	url = {http://link.springer.com/chapter/10.1007/978-3-319-11331-9{\_}24},
	year = {2014}
}
@article{Flasinski1993,
	abstract = {Further results of research into parsing of graph grammars for syntactic pattern recognition are presented (Comput. Vision Graphics Image Process. 47, 1-21 (1989); Pattern Recognition 23, 765-774 (1990)). A defined ETPL(k) graph grammar is a subfamily of a well-known edNLC graph grammar (Janssens and Rozenberg, Inf. Sci. 20, 191-216 (1980)) being a strong formalism for pattern representation. The subfamily generates a wider class of languages than the ones presented in the previous papers. An efficient parsing algorithm is constructed, its time complexity, o(n2), is evaluated, and experimental results are included. {\textcopyright} 1993.},
	author = {Flasi{\'{n}}ski, Mariusz},
	doi = {10.1016/0031-3203(93)90083-9},
	file = {:media/dados/2018-1/MasterThesis/Papers/Search/116{\_}Deterministic{\_}1-s2.0-0031320393900839-main.pdf:pdf},
	issn = {00313203},
	journal = {Pattern Recognition},
	keywords = {ETPL(k) graph grammar,Graph parsing,Syntactic pattern recognition,edNLC graph grammar},
	number = {1},
	pages = {1--16},
	title = {{On the parsing of deterministic graph languages for syntactic pattern recognition}},
	volume = {26},
	year = {1993}
}
@article{ehrig2015graph,
	title={Graph and Model Transformation},
	author={Ehrig, Hartmut and Ermel, Claudia and Golas, Ulrike and Hermann, Frank},
	year={2015},
	publisher={Springer}
}
@inproceedings{schurr1994specification,
title={Specification of graph translators with triple graph grammars},
author={Sch{\"u}rr, Andy},
booktitle={International Workshop on Graph-Theoretic Concepts in Computer Science},
pages={151--163},
year={1994},
organization={Springer}
}
@inproceedings{gilroy2017parsing,
	author = {Gilroy, Sorcha and Lopez, Adam and Maneth, Sebastian},
	booktitle = {Proceedings of the 6th Joint Conference on Lexical and Computational Semantics (* SEM 2017)},
	file = {:media/dados/2018-1/MasterThesis/Papers/14{\_}ParsingGraphsRegularGrammars{\_}document.pdf:pdf},
	pages = {199--208},
	title = {{Parsing Graphs with Regular Graph Grammars}},
	year = {2017}
}
@article{rekers1997defining,
	author = {Rekers, Jan and Sch{\"{u}}rr, Andy},
	file = {:media/dados/2018-1/MasterThesis/Papers/12{\_}VisualLanguages{\_}Schuerr{\_}RekersSchuerr1997.pdf:pdf},
	journal = {Journal of Visual Languages {\&} Computing},
	number = {1},
	pages = {27--55},
	publisher = {Elsevier},
	title = {{Defining and parsing visual languages with layered graph grammars}},
	volume = {8},
	year = {1997}
}
@article{Zhang2001,
	abstract = {Graph grammars may be used as natural and powerful syntax-definition formalisms for visual programming languages. Yet most graph-grammar parsing algorithms presented so far are either unable to recognize interesting visual languages or tend to be inefficient (with exponential time complexity) when applied to graphs with a large number of nodes and edges. This paper presents a context-sensitive graph grammar called reserved graph grammar, which can explicitly and completely describe the syntax of a wide range of diagrams using labeled graphs. The parsing algorithm of a reserved graph grammar uses a marking mechanism to avoid ambiguity in parsing and has polynomial time complexity in most cases. The paper defines a constraint condition under which a graph defined in a reserved graph grammar can be parsed in polynomial time. An algorithm for checking the condition is also provided.},
	author = {Zhang, Da Qian and Zhang, Kang and Cao, Jiannong},
	doi = {10.1093/comjnl/44.3.186},
	file = {:media/dados/2018-1/MasterThesis/Papers/13{\_}ContextSensitiveGraphGrammars{\_}217d73e0f6bbeefa3749c16fbc7b2e00ec0b.pdf:pdf},
	isbn = {0010-4620},
	issn = {00104620},
	journal = {Computer Journal},
	number = {3},
	pages = {186--200},
	title = {{A context-sensitive graph grammar formalism for the specification of visual languages}},
	volume = {44},
	year = {2001}
}
@inproceedings{adachi1999nce,
	title={An NCE context-sensitive graph grammar for visual design languages},
	author={Adachi, Yoshihiro and Kobayashi, Suguru and Tsuchida, Kensei and Yaku, Takeo},
	booktitle={Visual Languages, 1999. Proceedings. 1999 IEEE Symposium on},
	pages={228--235},
	year={1999},
	organization={IEEE}
}
@article{Marriott1997,
	abstract = {Visual language specification has been investigated for more than two decades now and many different formalisms for specifying and parsing visual languages have been invented. However, there has been little attempt to develop a systematic and comprehensive hierarchy of visual languages based on their formal properties. Given the importance of the Chomsky hierarchy for the theory of textual languages and the difficulty of comparing these many different visual language formalisms, it is clear that there is a need for such a hierarchy. We develop a hierarchy for visual languages and investigate the expressiveness and cost of parsing for classes defined therein. Although the hierarchy is based on the constraint multiset grammar formalism, we sketch how other visual language specification formalisms can be mapped into constraint multiset grammars so that a comparison is made possible. One consequence of our work is that a large class of 'naturally occurring' visual languages are inherently context-sensitive, so that the core of such a hierarchy has to be built around different forms of context-sensitivity. {\textcopyright} 1997 Academic Press Limited.},
	author = {Marriott, Kim and Meyer, Bernd},
	doi = {10.1006/jvlc.1997.0053},
	file = {:media/dados/2018-1/MasterThesis/Papers/39{\_}Hierarchy{\_}16e865fbdc81aa2cbb34216a73f8cc28238a.pdf:pdf},
	issn = {1045926X},
	journal = {Journal of Visual Languages and Computing},
	number = {4},
	pages = {375--402},
	title = {{On the classification of visual languages by grammar hierarchies}},
	volume = {8},
	year = {1997}
}
@article{Shi2016,
	abstract = {{\textcopyright} 2015 IEEE. A graph grammar is a formal tool for providing rigorous but intuitive ways to define visual languages. However, the description and implementation difficulties of graph grammars hinder their wide applications. This paper, first of all introduces a description mechanism for specifying the existing Edge-based Graph Grammar (EGG) by using the XML techniques. Then, based on the mechanism, a new parsing algorithm is proposed, which is easily designed and implemented by using the XML technique.},
	author = {Shi, Zhan and Zeng, Xiaoqin and Huang, Song and Qi, Zekun and Li, Hui and Hu, Bin and Zhang, Sainan and Liu, Yanyun and Wang, Cailing},
	doi = {10.1109/ICCCNT.2015.7395225},
	file = {:media/dados/2018-1/MasterThesis/Papers/Search/08{\_}Simplify{\_}07395225.pdf:pdf},
	isbn = {9781479979844},
	journal = {6th International Conference on Computing, Communications and Networking Technologies, ICCCNT 2015},
	keywords = {EGG,XML,graph grammar,parsing algorithm},
	pages = {2--7},
	title = {{A method to simplify description and implementation of Graph Grammars}},
	year = {2016}
}
@article{Drewes2010,
	abstract = {Motivated by applications that require mechanisms for describing the structure of object-oriented programs, adaptive star grammars are introduced, and their fundamental properties are studied. In adaptive star grammars, rules are actually schemata which, via the cloning of so-called multiple nodes, may adapt to potentially infinitely many contexts when they are applied. This mechanism makes adaptive star grammars more powerful than context-free graph grammars. Nevertheless, they turn out to be restricted enough to share some of the basic characteristics of context-free devices. In particular, the underlying substitution operator enjoys associativity and confluence properties quite similar to those of context-free graph grammars, and the membership problem for adaptive star grammars is decidable. {\textcopyright} 2010 Elsevier B.V.},
	author = {Drewes, Frank and Hoffmann, Berthold and Janssens, Dirk and Minas, Mark},
	doi = {10.1016/j.tcs.2010.04.038},
	file = {:media/dados/2018-1/MasterThesis/Papers/Search/29{\_}Star{\_}1-s2.0-S0304397510002550-main.pdf:pdf;:media/dados/2018-1/MasterThesis/Papers/41{\_}Axiomatic-ContextFree{\_}1-s2.0-0304397587901022-main.pdf:pdf},
	issn = {03043975},
	journal = {Theoretical Computer Science},
	keywords = {Context-free graph language,Graph grammar,Graph parsing,Node cloning},
	number = {34-36},
	pages = {3090--3109},
	publisher = {Elsevier B.V.},
	title = {{Adaptive star grammars and their languages}},
	url = {http://dx.doi.org/10.1016/j.tcs.2010.04.038},
	volume = {411},
	year = {2010}
}
@article{Flasinski1998,
	author = {Flasiński, M},
	doi = {http://dx.doi.org/10.1016/S0304-3975(97)00212-0},
	file = {:media/dados/2018-1/MasterThesis/Papers/Search/21{\_}NLC-ploynomial{\_}1-s2.0-S0304397597002120-main.pdf:pdf},
	issn = {03043975},
	journal = {Theoretical Computer Science},
	keywords = {graph grammars,graph parsing,membership},
	number = {8},
	pages = {189--231},
	title = {{Power properties of NLC graph grammars with a polynomial membership problem}},
	volume = {201},
	year = {1998}
}
@article{Flasinski1993,
	abstract = {Further results of research into parsing of graph grammars for syntactic pattern recognition are presented (Comput. Vision Graphics Image Process. 47, 1-21 (1989); Pattern Recognition 23, 765-774 (1990)). A defined ETPL(k) graph grammar is a subfamily of a well-known edNLC graph grammar (Janssens and Rozenberg, Inf. Sci. 20, 191-216 (1980)) being a strong formalism for pattern representation. The subfamily generates a wider class of languages than the ones presented in the previous papers. An efficient parsing algorithm is constructed, its time complexity, o(n2), is evaluated, and experimental results are included. {\textcopyright} 1993.},
	author = {Flasi{\'{n}}ski, Mariusz},
	doi = {10.1016/0031-3203(93)90083-9},
	file = {:media/dados/2018-1/MasterThesis/Papers/Search/116{\_}Deterministic{\_}1-s2.0-0031320393900839-main.pdf:pdf},
	issn = {00313203},
	journal = {Pattern Recognition},
	keywords = {ETPL(k) graph grammar,Graph parsing,Syntactic pattern recognition,edNLC graph grammar},
	number = {1},
	pages = {1--16},
	title = {{On the parsing of deterministic graph languages for syntactic pattern recognition}},
	volume = {26},
	year = {1993}
}
@article{Gottmann2016,
	abstract = {Copyright {\textcopyright} by the paper's authors.Models are the keystones in model-driven systems development. They describe systems at different layers of abstraction and with a focus to different domains. For each domain, dedicated domain specific visual modelling languages are used for model definitions with the idea to separate concerns to different domain experts. This enables precise problem and requirement definitions and should decrease efforts in developing and validating systems. We focus on multi-view models that are in relationship with source models by triple graph grammars. A multi-view model provides different views of the source model at different layers of abstraction but within the same DSL which is typically different from the DSL of the source model. In practice, elements in different views may overlap. We present an informal methodology for consistently propagating updates from one view to the other views and also to the source domain. We motivate our approach by multi-view models in a hospital scenario.},
	author = {Gottmann, Susann and Nachtigall, Nico and Engel, Thomas and Ermel, Claudia and Hermann, Frank},
	file = {:media/dados/2018-1/MasterThesis/Papers/00{\_}PropagationModelUpdates.pdf:pdf},
	issn = {16130073},
	journal = {CEUR Workshop Proceedings},
	number = {Bx},
	pages = {45--60},
	title = {{Towards the propagation of model updates along different views in multi-view models}},
	volume = {1571},
	year = {2016}
}
@article{Shi2014,
	abstract = {{\textcopyright} 2014 IEEE. As a graphical language, the Business Process Modelling Notation (BPMN) plays an important role in enterprise information systems. BPMN is a standard notation for capturing business processes, while Business Process Execution Language (BPEL) provides a standard executable language for specifying business process compositions and interactions. This paper proposes a new method based on graph grammars to map from BPMN to BPEL codes. In the first place, the existing Edge-based Graph Grammar (EGG) is introduced, which is a context-sensitive grammar and a new formal method for simply specifying graph grammars. Secondly, some aspects of EGGs are extended to conveniently map from BPMN to BPEL. Finally, new mapping steps and a parsing algorithm are put forward, which achieve a goal of this paper.},
	author = {Shi, Z and Zeng, X and Huang, S and Li, H and Hu, B and Lei, X and Wang, Y},
	doi = {10.1109/ICCCNT.2014.6963105},
	file = {:media/dados/2018-1/MasterThesis/Papers/Search/01{\_}BPM-BPEL{\_}6963105.pdf:pdf},
	isbn = {VO  -},
	journal = {Computing, Communication and Networking Technologies (ICCCNT), 2014 International Conference on},
	keywords = {BPEL,BPEL codes,BPMN,BPMN codes,Business,Context,EGG,Educational institutions,Grammar,Information systems,Production,Visualization,Web Services Business Process Execution Language,business data processing,business process compositions,business process execution language,business process interactions,business process modelling notation,context-sensitive grammar,context-sensitive grammars,edge-based graph grammar,enterprise information systems,formal method,graph grammar,graph grammars,graphical language,parsing algorithm,standard executable language,transformation,visual languages},
	pages = {1--6},
	title = {{Transformation between BPMN and BPEL based on graph grammar}},
	year = {2014}
}
@article{Bisztray2009,
	abstract = {Model transformations can be used not only for code or platform-specific model generation, but also for denotational semantics definition, e.g. using process algebras as semantics for visual modeling languages. Denotational semantics of programming languages are by definition compositional. In order to enjoy a similar property in the case of model transformations, every component of the source model should be distinguishable in the target model and the mapping compatible with syntactic and semantic composition. Since typed graphs are a natural representation of visual models, model transformations are often described by typed graph transformations. This paper proposes a formal definition of compositionality for mappings from typed graphs to semantic domains. To verify compositionality, syntactic criterion has been established for the implementation of the mappings by graph transformations with negative application conditions. An example compositional transformation is presented that maps architectural models described in UML component diagrams to CSP. Crown Copyright {\textcopyright} 2009.},
	author = {Bisztray, D{\'{e}}nes and Heckel, Reiko and Ehrig, Hartmut},
	doi = {10.1016/j.entcs.2009.03.011},
	file = {:media/dados/2018-1/MasterThesis/Papers/Search/40{\_}Compositionality{\_}1-s2.0-S1571066109000905-main.pdf:pdf;:media/dados/2018-1/MasterThesis/Papers/42{\_}FirstTGG{\_}{\_}Specification{\_}of{\_}Graph{\_}Translators{\_}with{\_}Triple{\_}Gra.pdf:pdf},
	isbn = {1571-0661},
	issn = {15710661},
	journal = {Electronic Notes in Theoretical Computer Science},
	keywords = {category theory,compositionality,denotational semantics,graph transformation,model driven engineering,typed graphs},
	number = {C},
	pages = {5--19},
	title = {{Compositionality of Model Transformations}},
	volume = {236},
	year = {2009}
}
@article{Striewe2008,
	abstract = {State machines can be comprehensively specified, simulated and validated at design time to get a formally founded skeleton for a software application. A direct implementation of state machines in Java source code can realize states as classes, transitions as methods and variables as well as pre-conditions and variable updates as auxilliary methods, invoking either arbitrary application methods to retrieve the current variable values or evaluating expressions [1]. Viewed from an abstract level, implementation and state machine are two models, sharing the same semantics. To maintain the modelled software systems, it is vitally important to perserve as much of this semantics as possible in the source code to be able to track back changes and errors [2,3]. In contrast to these considerations, current techniques of model-driven development use several unidirectional steps, starting from an abstract model and resulting in platfrom specific source code. Graph Transformations Graph Transformations Look Inside Share Share this content on Facebook Share this content on Twitter Share this content on LinkedIn Other actions Export citations About this Book Reprints and Permissions},
	author = {Striewe, Michael},
	doi = {10.1007/978-3-540-87405-8_50},
	file = {:media/dados/2018-1/MasterThesis/Papers/Search/69{\_}TGGForSM{\_}978-3-540-87405-8{\_}50.pdf:pdf},
	isbn = {3540874046},
	issn = {03029743},
	journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
	pages = {514--516},
	title = {{Using a triple graph grammar for state machine implementations}},
	volume = {5214 LNCS},
	year = {2008}
}
@article{Pratt1971,
	abstract = {Translation between string and graph representations of programs and data may be formally defined by means of pair grammars. A pair grammar is composed of a pair of grammars whose rules and nonterminals are paired. The pair grammar defines a correspondence between elements of the languages defined by the two grammars. This correspondence may be viewed as a definition of the translation of the elements of one language into the elements of the other. Of particular interest is the case in which the first language is a set of strings and the second is a set of directed graphs with labeled arcs and nodes. Preliminary to the definition of pair grammars, a class of graph grammars are defined which are a generalization of ordinary context-free grammars. A graph grammar defines a language composed of a set of directed graphs. Pair grammars are constructed from pairs of graph grammars. Each unambiguous pair grammar defines a reversible function mapping one graph language onto another. Special cases of interest include string-to-graph, graph-to-string, and string-to-string mappings. In the general case a pair grammar defines a transformation on a set of graphs. Two extensions to the elementary pair grammars allow representation of hierarchies of graphs and constructs such as labels and go to statements. Examples are given of the translation of a major subset of Algol into flowchart graphs and the translation of Lisp S-expressions into list structure graphs with structured atoms. {\textcopyright} 1971 Academic Press, Inc.},
	author = {Pratt, Terrence W.},
	doi = {10.1016/S0022-0000(71)80016-8},
	file = {:media/dados/2018-1/MasterThesis/Papers/Search/114{\_}Pair{\_}1-s2.0-S0022000071800168-main.pdf:pdf},
	issn = {10902724},
	journal = {Journal of Computer and System Sciences},
	number = {6},
	pages = {560--595},
	title = {{Pair grammars, graph languages and string-to-graph translations}},
	volume = {5},
	year = {1971}
}
@article{Giese2009,
	abstract = {The model-driven software development paradigm requires that appropriate model transformations are applicable in different stages of the development process. The transformations have to consistently propagate changes between the different involved models and thus ensure a proper model synchronization. However, most approaches today do not fully support the requirements for model synchronization and focus only on classical one-way batch-oriented transformations. In this paper, we present our approach for an incremental model transformation which supports model synchronization. Our approach employs the visual, formal, and bidirectional transformation technique of triple graph grammars. Using this declarative specification formalism, we focus on the efficient execution of the transformation rules and how to achieve an incremental model transformation for synchronization purposes. We present an evaluation of our approach and demonstrate that due to the speedup for the incremental processing in the average case even larger models can be tackled.},
	author = {Giese, Holger and Wagner, Robert},
	doi = {10.1007/s10270-008-0089-9},
	file = {:media/dados/2018-1/MasterThesis/Papers/Search/89{\_}ModelTrans-Bidirection{\_}s10270-008-0089-9.pdf:pdf},
	isbn = {1027000800},
	issn = {16191366},
	journal = {Software and Systems Modeling},
	keywords = {Incremental model synchronization,Model transformation,Triple graph grammars},
	number = {1},
	pages = {21--43},
	title = {{From model transformation to incremental bidirectional model synchronization}},
	volume = {8},
	year = {2009}
}
@inproceedings{leblebici2014developing,
	title={Developing eMoflon with eMoflon},
	author={Leblebici, Erhan and Anjorin, Anthony and Sch{\"u}rr, Andy},
	booktitle={International Conference on Theory and Practice of Model Transformations},
	pages={138--145},
	year={2014},
	organization={Springer}
}