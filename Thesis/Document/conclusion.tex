%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CONCLUSION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In this thesis, a novel triple graph grammar formalism that includes non-terminal symbols is proposed. This formalism is the product of the combination of an already existent graph grammar formalism with non-terminal symbols, called \emph{graph grammar with neighborhood controlled embedding} (NCE), with the traditional triple graph grammar (TGG). We name this new fromalism NCE TGG and propose in this thesis a syntactical and semantical characterization of it. Furthermore, we present an extension of the NCE TGG that supports application conditions and increases its generative power in such an extand that allows us to apply it for real world situations, we name this extension PAC NCE TGG. For the purpose of illustrating the application of our formalism, we demonstrate how it can be used to solve the model transformation problem, which is a very relevant problem for the model-driven software development realm. Ultimately, we provide an evaluation of the usability and performance of the NCE TGG for this problem and discuss these results.

%%%%% Extended summary %%%%%
In summary, a NCE TGG is a grammar that generates a language of triple graphs. This grammar consists, basically, of an alphabet (partitioned into terminal and non-terminal symbols) and a set of rules of the form $(A \pro R,\omega_s,\omega_t)$, where $A$ is a non-terminal symbol of the alphabet and is called left-hand side, $R$ is any triple graph over the alphabet and is called right-hand side, and $\omega_s$ and $\omega_t$ are the embedding functions that determine how the right-hand side is to be used in a rule application.

Given a triple graph $G$ over the alphabet, a rule application in this grammar that generates a new triple graph $H$ (we write $G \tcderiv{}{}{} H$) is done by (1) removing any triple of vertices with label $A$ from $G$, (2) inserting $R$ in $G$ and adding edges between the removed vertices neighbors and the $R$'s vertices according to the functions $\omega_s$ and $\omega_t$. A triple graph containing only terminal symbols generated by a sequence of rule applications starting from a special start symbol is in the language of the grammar.

We believe that the key on understanding how a NCE TGG works lies on how the embedding functions $\omega_s$ and $\omega_t$ work. These functions map from a vertex of $R$ and an edge label to a vertex label. In this regard, if $v$ is a vertex of $R$ and $\omega_s(v,\alpha) = \beta$, then on any application of this rule, $v$ will be connected to every $\beta-$labeled vertex through an $\alpha-$labeled edge of the graph being modified, if the removed vertex had such an adjacent vertex with an $\alpha-$labeled edge.

We are aware that these embedding functions make the semantics of the rule application seem quite complicated for the unused reader. This difficulty stems from the fact that it is hard for a human to imagine on creation-time how a rule will behave when applied to vertices with different neighbors. That is, a priori, it is out of the control of the rule, which and how many neighbors will a removed vertex have. Therefore, we call for more investigations on how to make the NCE TGG's semantics more comprehensible for humans. It is possible that formalisms in which the context of the removed vertex is made more clear lead to a better understanding of the rule application. One of such formalisms is the \emph{hyperedge replacement grammars} (HRG), where the left-hand side of a rule consists of a hyperedge connected to a fixed set of vertices. Another solution could be the explicit addition of context to the left-hand side of the rules, although it would imply the necessity for a totally new parsing and transformation algorithm.

The PAC NCE TGG extension does not solve the issue with the embeddings but does add generative power to the grammar by means of special vertices in $R$ that are generated by rule applications and removed by so-called resolutions, we name these vertices PAC vertices. Therewith, a rule application may end up connecting vertices generated by other rule applications that could not be added without PAC vertices. We are also aware about the complication that such extension adds to the comprehension of the semantics and of the parsing algorithm for PAC NCE TGG.

Nevertheless, we are convinced that the discussions driven throughout this thesis shed a light at the current state-of-the-art of NCE graph grammars and triple graph grammars. In especial regarding the imperative characterization of the parsing and transformation algorithms exposed here. Such algorithms are often described in a less accessible way in academic literature.

As stated above, we demonstrate, additionally, the application of the NCE TGG and PAC NCE TGG on the solving of the model transformation problem. When two correctly transformed models are packed in a triple graph, then the set of all correctly transformed models is the language of a TGG. By being so, the problem of model transformation reduces in polynomial time to the problem of parsing a graph with a graph grammar. We expose therefore a parsing algorithm for NCE TGG \cite{rozenberg1986boundary} and PAC NCE TGG that has polynomial worst-case time complexity for degree-bounded connected graphs. This algorithm is based on the CYK parser for string grammars and applies dynamic programming techniques to construct bottom-up a parsing tree for the input graph. The algorithm starts by constructing parsing trees for subgraphs of the input graph using the grammar rules and tries to increase the size of such parsing trees until one of them cover the whole input graph. Hence, this process can be seen as a systematic exploration of the search space of parsing trees for the grammar, which is big. And as our parser cannot impede unproductive explorations of it, it ends up often performing unnecessary computations which affects negatively the method's performance.

Therefore, we would wish to have a more efficient parsing algorithm, that implemented, for example, better search heuristics. Another alternative would be the design of a top-down parser, which can construct parsing trees more eagerly. The problem of a top-down parser is that it needs to backtrack a priori, what implies a exponential complexity.
 
The actual transformation algorithm for NCE TGG consists basically of applying each rule of the derivation returned by the parser to produce the final triple graph holding the input graph and the transformed graph, this method is proved to be correct by Theorem \ref{thm:one_d_enough}. The transformer for PAC NCE TGG differs from the former in which it produces the output triple graph in a two-pass manner. First, it produces all vertices and edges according to the derivation given by the parser and, second, it resolves the PAC vertices, removing them and connecting their edges with correspondent normal vertices. Theorem \ref{thm:one_d_enough_pac} also proves this method's correctness.

Throughout this thesis, we use the term model transformation to refer actually to batch forward model transformation, in which the target model is created from scratch and the source model is not to be created out of the target. Nonetheless, it is clear, by the symmetry of triple graphs, that our approach suits also bidirectional transformations, in which the source model may also be generated from the target. On the other hand, our approach does not befit incremental transformation, in which the source and target model already exist and are to be only incremented with the new changes. The reason for that is twofold, first, the output of the transformation is possibly non-deterministic for the case of ambiguous grammars or non-functional transformations. Second, even for unambiguous functional transformations, the output could only be equal up to isomorphism. Informally, this means, we could not guarantee the maintenance of the ids of the input vertices that are not modified. It is, thus, needless to say that our approach also does not suit a priori the incremental bidirectional model synchronization problem, also known as model synchronization problem.

%TODO: Write what lexicalization means and add citation
We believe, though, that the lexicalization of NCE TGG may be a future direction of research for the support of model synchronization. Lexicalization consists, basically, on ...

%%%%% Results %%%%%
All in all, our proposed TGG formalism is expressive enough to model practice-relevant transformations as well as transformations involving graphs in diverse forms, e.g. unrooted, non-connected, and cyclic graphs. The usability evaluation in Section \ref{sec:eval-usability} evinces its potential by showing that our approach outperforms standard TGG in two of five cases, as well as, in the total and average measurements of the sizes of these five evaluated transformations. In addition, due to the monotonicity of TGG, we cannot specify one of the transformations with it, whereas we can with NCE TGG.

But the benefits of our approach is not restricted to that. Our usability evaluation asseses only one aspect of the grammars, which is their size. We believe, though, that other aspects also corroborate positively for the good usability of NCE TGG. For instance, the capability of representing abstract concepts by means of non-terminal symbols and the possibility to have the empty graph as the right-hand side of a rule. In order to measure the effect of these aspects in the usability perceived by the engineers we would call for an empyrical subjective evaluation involving experts.

%%%%% Future Work %%%%%
A further future work for this thesis would be the expansion and deepening of the theoretical analysis of the NCE TGG formalism. In this regard, we call for an examination of the expressiveness of NCE TGG with the goal to find possible proper subclasses of it with less generative power than it or to find out whether PAC NCE TGG is more expressve than standard TGG in the generative power sense, that is, whether the former's set of possible languages contains properly the set of all possible languages of the former. Analogously, the proof of soundness and completeness of our transformer is also topic for future investigation.

Furthermore, we think that advances can be done in the determination of sufficient and necessary conditions for a transformation specified with NCE TGG to be functional.

%%%%% Perspective - Outlook %%%%%
%TODO: FAZIT
%TODO: Say downside: Fewer theoretical results as TGG. It has stronger theory (category theory) behind it.


%TODO cite: s_52,s_93





