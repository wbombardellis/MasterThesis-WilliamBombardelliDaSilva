%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CONCLUSION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In this thesis, a novel triple graph grammar formalism that includes non-terminal symbols is proposed. This formalism is the product of the combination of an already existent graph grammar formalism with non-terminal symbols, called \emph{graph grammar with neighborhood controlled embedding} (NCE), with the traditional triple graph grammar (TGG). We name this new fromalism NCE TGG and propose in this thesis a syntactical and semantical characterization of it. Furthermore, we present an extension of the NCE TGG that supports application conditions and increases its generative power in such an extand that allows us to apply it for real world situations, we name this extension PAC NCE TGG. For the purpose of illustrating the application of our formalism, we demonstrate how it can be used to solve the model transformation problem, which is a very relevant problem for the model-driven software development realm. Ultimately, we provide an evaluation of the usability and performance of the NCE TGG for this problem and discuss these results.

%%%%% Extended summary %%%%%
%TODO: IMPORTANT: ADD CONDITION FOR TRIPLE RULE APPLICATION - THREE VERTICES NEED TO BE CONNECTED BY THE MORPHISM
In summary, a NCE TGG is a grammar that generates a language of triple graphs. This grammar consists, basically, of an alphabet (partitioned into terminal and non-terminal symbols) and a set of rules of the form $(A \pro R,\omega_s,\omega_t)$, where $A$ is a non-terminal symbol of the alphabet and is called left-hand side, $R$ is any triple graph over the alphabet and is called right-hand side, and $\omega_s$ and $\omega_t$ are the embedding functions that determine how the right-hand side is to be used in a rule application.

Given a triple graph $G$ over the alphabet, a rule application in this grammar that generates a new triple graph $H$ (we write $G \tcderiv{}{}{} H$) is done by (1) removing any triple of vertices with label $A$ from $G$, (2) inserting $R$ in $G$ and adding edges between the removed vertices neighbors and the $R$'s vertices according to the functions $\omega_s$ and $\omega_t$. A triple graph containing only terminal symbols generated by a sequence of rule applications starting from a special start symbol is in the language of the grammar.

We believe that the key on understanding how a NCE TGG works lies on how the embedding functions $\omega_s$ and $\omega_t$ work. These functions map from a vertex of $R$ and an edge label to a vertex label. In this regard, if $v$ is a vertex of $R$ and $\omega_s(v,\alpha) = \beta$, then on any application of this rule, $v$ will be connected to every $\beta-$labeled vertex through an $\alpha-$labeled edge of the graph being modified, if the removed vertex had such an adjacent vertex with an $\alpha-$labeled edge.

We are aware that these embedding functions make the semantics of the rule application seem quite complicated for the unused reader. This difficulty stems from the fact that it is hard for a human to imagine on creation-time how a rule will behave when applied to vertices with different neighbors. That is, a priori, it is out of the control of the rule, which and how many neighbors will a removed vertex have. Therefore, we call for more investigations on how to make the NCE TGG's semantics more comprehensible for humans. It is possible that formalisms in which the context of the removed vertex is made more clear lead to a better understanding of the rule application. One of such formalisms is the \emph{hyperedge replacement grammars} (HRG), where the left-hand side of a rule consists of a hyperedge connected to a fixed set of vertices. Another solution could be the explicit addition of context to the left-hand side of the rules, although it would imply the necessity for a totally new parsing and transformation algorithm.

The PAC NCE TGG extension does not solve the issue with the embeddings but does add generative power to the grammar by means of special vertices in $R$ that are generated by rule applications and removed by so-called resolutions, we name these vertices PAC vertices. Therewith, a rule application may end up connecting vertices generated by other rule applications that could not be added without PAC vertices. We are also aware about the complication that such extension adds to the comprehension of the semantics and of the parsing algorithm for PAC NCE TGG.

Nevertheless, we are convinced that the discussions driven throughout this thesis shed a light at the current state-of-the-art of NCE graph grammars and triple graph grammars. In especial regarding the imperative characterization of the parsing and transformation algorithms exposed here. Such algorithms are often described in a less accessible way in academic literature.

As stated above, we demonstrate the application of the NCE TGG and PAC NCE TGG on the solving of the model transformation problem. When two correctly transformed models are packed in a triple graph, then the set of all correctly transformed models is the language of a TGG. By being so, the problem of model transformation reduces in polynomial time to the problem of parsing a graph with a graph grammar. We expose therefore a parsing algorithm for NCE TGG \cite{rozenberg1986boundary} and PAC NCE TGG that has polynomial worst-case time complexity. This algorithm is based on the CYK parser for string grammars and applies dynamic programming techniques to construct bottom-up a parsing tree for the input graph. The algorithm starts by constructing parsing trees for subgraphs of the input graph using the grammar rules and tries to increase the size of such parsing trees until one of them cover the whole input graph. Hence, this process can be seen as a systematic exploration of the search space of parsing trees for the grammar, which is big. And as our parser cannot impede unproductive explorations of it, it ends up often performing unnecessary computations which affects negatively the method's performance.

Therefore, we would wish to have a more efficient parsing algorithm, that implemented, for example, better search heuristics. Another alternative would be the design of a top-down parser, which can construct parsing trees more eagerly. The problem of a top-down parser is that it needs to backtrack a priori, what implies a exponential complexity.
 
The transformation algorithm for NCE TGG consists basically of applying each rule of the derivation returned by the parser to produce the final triple graph holding the input graph and the transformed graph, this method is proved to be correct by Theorem \ref{thm:one_d_enough}. The transformer for PAC NCE TGG differs from the former in which it produces the output triple graph in a two-pass manner. First, it produces all vertices and edges according to the derivation given by the parser and, second, it resolves the PAC vertices, removing them and connecting their edges with correspondent normal vertices. Theorem \ref{thm:one_d_enough_pac} also proves this method's correctness.


%TODO: Enhancement: left hand side more flexible with three different symbols (e.g. A-B-C -> ...)
%TODO: In conclusion, discourse about incremental transformation and synchronization
%TODO: In conclusion, discuss about necessity for sufficient and necessary conditions for non-functional transformations, as well as correctness in TGG sense and other theorethical analysis.

%TODO: Maybe talk more about the normalization for TGG

%%%%% Results %%%%%
%TODO: Expressive enough to model non connected graphs, unrooted, with cycles 
%TODO: Talk about the empty productions, that are allowed :)
%TODO: Say this evaluation measures only one aspect of the usability (size), we wished to evaluate how a modeller would work with it -> empyrism

%%%%% Future Work %%%%%
%TODO: Future work (e.g. lexicalization for model synchronization).
%TODO: Future work: more theoretical results concersing e.g. expressiveness, completeness and correctenss (in the TGG sense)
%TODO: Future work: we call for empyrical analysis to evaluate usability not in terms of siye but in terms of perceived usability by modelers - Lack of context may be perceived negatively by some


%%%%% Perspective - Outlook %%%%%
%TODO: FAZIT
%TODO: Say downside: Fewer theoretical results as TGG. It has stronger theory (category theory) behind it.


%TODO cite: s_52,s_93





