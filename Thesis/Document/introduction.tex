%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%% INTRODUCTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%TODO: Maybe at some point of this intro add a scheme explaining the thesis graphically
One of the biggest challenges for the construction of software is to construct high-quality software artifacts. The success of a software project is very often decided by the quality aspects of the produced outcome. These aspects include, among others, correctness, reliability, security, usability, and performance. Despite its importance, quality is frequently not achieved in software products. To overcome that, software engineering techniques of several kinds have been created. These techniques range from people and process management, test and verification methods up to construction standards, like coding guidelines, model checking and the model-driven software development (MDSD) approach.

The MDSD approach for software construction places the use of software models at the center of the building process. The term ``model'' is understood as an artifact that represents some part of a software system, that is, it encodes, possibly more abstractly, some aspects of this systems. One example of a model for an object-oriented software system is a class diagram, which encodes the classes that compose the system in a more abstract manner than the actual system does. Notably, abstraction plays an important role by the MDSD approach, for it shall allow better reasonings about aspects of interest. In other words, engineers discoursing about a model that holds only the information in which they are interested, should be less prone to be distracted by noise and, thus, less prone to make mistakes.

But as the use of models grows, also grows the need for tools that support engineers in tasks like storage and management of models, model checking, model verification or model transformation. The latter is a special problem of the realm of MDSD and consists, basically, on creating models automatically out of other models. In practice, the possibility of transforming models comes from the fact that different models may represent intersecting parts of the system under construction. One example of such a situation is the transformation of a class diagram into source-code or the compilation of source-code into machine-code.

%TODO: Cite QVT-O, QVT-R, ATL, GG
Numerous solutions for the model transformation problem have been proposed by academy and industry. One branch of such solutions is the so-called operational approach, which focuses on the description of transformations either through imperative general-purpose languages, like Java, or domain-specific languages, like QVT-O. Another branch is the so-called relational approach, which focuses on the specification of transformations by means of a declarative language or formalism that embodies the relations between the elements of the different models to be transformed. Examples for this approach include QVT-R, ATL, and the graph grammar approach, which is grounded in the theories of graphs and formal languages to formalize models and describe relations between them. A specialization of the graph grammar formalism is the triple graph grammar (TGG) \cite{schurr1994specification}, that consists of specifying transformations by means of context-sensitive grammars of, so-called, triple graphs.

Triple graphs are composed of three graphs, the source and the target graphs, representing two models, and the correspondence graph that connects the source and the target through arrows. A triple graph can be used to express the relationship between two graphs through the arrows between their vertices. More formally, a triple graph $G_s \ms{ms} G_c \mt{mt} G_t$ consists of three disjunct labeled graphs $G_s$, $G_c$, $G_t$, called source, correspondence, and target graphs, respectively, where the $G_s$ and $G_t$ contain elements of the two models of interest, and $G_c$ contains elements that connect $G_s$ and $G_t$ via two partial mappings $ms: G_c \pto G_s$ and $mt: G_c \pto G_t$ \cite{schurr1994specification}.

A TGG consists of a set of rules of the form $L \pro R$, where $L$ and $R$ are triple graphs. The application of a rule $L \pro R$ on a triple graph $G$ can be informally understood as the replacement of the occurrence of $L$ in $G$ by $R$. By this means, a TGG, analogously to common string grammars, characterizes a language of triple graphs, that consists of all triple graphs generated by consecutive rule applications starting from a special initial triple graph $Z_G$. In this sense, a TGG describes a language of pairs of graphs whose vertices have a certain relationship. For the context of model transformation, in which one is interested in defining a translator from a source model to a target model, a TGG can be used to describe the set of all correctly translated source models and its correspondent target models, in form of a language of triple graphs.

Despite the various positive aspects of TGG, like a well-founded theory and a reasonable tool support \cite{anjorin201620}, we have identified, that for some scenarios, a transformation described with TGG results in a grammar that is too big and difficult to comprehend. We judge, this downside stems from the absence of the concept of non-terminal symbols in the TGG formalism. This concept allows, in the theory of formal languages, for a very effective representation of abstract entities in string grammars, what in turn makes grammars more comprehensible and easier to build. Moreover, it enables the hierarchical classification of grammars, known as the Chomsky hierarchy \cite{chomsky1959}, that assigns different theoretical characteristics (e.g. generative power, parsing complexity) to different classes. Such characteristics have paved the way for the implementation of efficient parsers for specific classes of grammars, as well as, efficient compiler generators for programming languages.

We expect that a TGG formalism that describes model transformations in a more compact manner and that makes it possible to encode models' abstract concepts efficiently through non-terminal symbols be more comprehensible and make model transformations easier to be constructed, verified and validated. Therewith, such a TGG would lead to an enhancement of the quality of the software being constructed.

Hence, motivated by this benefit, the main objective of this thesis is to provide a novel formalism that redefines the standard triple graph grammars and introduces the notion of non-terminal symbols to create a context-free triple graph grammar formalism. In particular, we also aim at reviewing key aspects of the current state-of-the-art, like the parsing of graph grammars; at discussing some theoretical and practical aspects of our new TGG formalism; and at demonstrating how it can be used for solving the model transformation problem.

In order to build our new TGG formalism, we mix an already established graph grammar technique that supports non-terminal symbols called \emph{graph grammar with neighborhood-controlled embedding} (NCE graph grammar) \cite{janssens1982graph} and the standard definition of TGG \cite{schurr1994specification} and name it NCE TGG. A NCE TGG consists of a set of rules of the form $A \pro R$, where $A$ is a symbol and $R$ is a triple graph. The application of a rule $A \pro R$ on a triple graph $G$ can be informally understood as the replacement of the occurrence of a vertex labeled with $A$ in $G$ by $R$. As in the standard TGG, a NCE TGG also characterizes a language of triple graphs holding all correctly transformed source and target graphs.

In order to demonstrate the application of our approach, we formalize the model transformation problem and show, supported by theoretical results, that a NCE TGG can be used to specify model transformations, which are then executed by our transformation algorithm with polynomial time complexity. To enhance the generative power of our basic version of NCE TGG, we extend it with a mechanism of application conditions, called PAC NCE TGG, that allows us to study our proposal in more practical scenarios and for which we also develop a parsing and a transformation algorithm. The challenges and problems of a concrete implementation of such algorithms are also discussed and a case study containing an analysis in depth of two instances of the model transformation problem specified with NCE TGG and PAC NCE TGG is thereupon put forward.

Lastly, for the purpose of evaluating the usability of our proposal, we compare the size of 5 model transformations specified with PAC NCE TGG and with the standard TGG. To assess the performance of our implemented transformer, we execute it on the same model transformation specifications for several models with different sizes and report the results.

In summary, our proposed PAC NCE TGG formalism outperforms the standard TGG in one of the 5 evaluated cases with a specification almost one order of magnitude smaller, and is able to describe one model transformation that we could not do with the standard TGG. Moreover, in the average and total measurements, our approach produces smaller grammars. Negatively, PAC NCE TGG is outperformed by standard TGG in the other 3 evaluated cases and our implementation is considerably slower than the state-of-the-art for TGG transformer eMoflon \cite{leblebici2014developing}. Nonetheless, we believe that the outcomes of this thesis are of relevance for the current state of the research in the field and we judge that it contributes positively for the state-of-the-art.

The remainder of this thesis is as follows, in Chapter \ref{ch:RelatedWorks} we present a literary review of research works related to this thesis with a special focus on the topic of graph grammars with non-terminal symbols; in Chapter \ref{ch:TheoreticalReview} we provide the theoretical background necessary for the definition of the NCE TGG formalism; in Chapter \ref{ch:ModelTransformation} we present our argumentation of how NCE TGG solves the model transformation problem and a transformation algorithm; in Chapter \ref{ch:PacExtension} we extend NCE TGG by adding application conditions and demonstrate how the parsing and transformation works for this extension; in Chapter \ref{ch:Implementation} we discuss the details and open challenges of our implemented transformer; in Chapter \ref{ch:CaseStudy} two representative examples for specifications of model transformations with NCE TGG and PAC NCE TGG are analyzed in depth aiming for the practical application of our proposal; in Chapter \ref{ch:Evaluation} an experimental evaluation of usability and performance is exposed; and, finally, in Chapter \ref{ch:Conclusion} we close our exposition with a summary and an outlook about this work.
