%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%% INTRODUCTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
One of the biggest challenges of the construction of software is the production of high-quality software artifacts. The success of a software project is often decided by the quality aspects of the produced outcome. These aspects include, among others, correctness, reliability, security, usability, performance, and others. Despite its importance, quality is frequently not achieved by software products. To overcome that, software engineering techniques of several kinds have been created. These techniques range from people and process management, test and verification methods up to construction standards, like coding guidelines, model checking and model-driven software development (MDSD).

The MDSD approach for software construction places the use of software models at the center of the building process. The term ``model'', here, is understood as an artifact that represents some part of a software system, that is, an artifact that encodes, possibly more abstractly, some aspects of this systems. One example of a model for an object-oriented software system is a class diagram, which encodes the classes that compose the system in a more abstract manner than the actual system does. Notably, abstraction plays an important role by the MDSD approach, for it shall allow better reasonings about the aspects of interest. In other words, engineers discoursing about a model that holds only the information in which they are interested should be less prone to be distracted by unimportant information and, thus, less prone to make mistakes.

But as the use of models grows, the need for tools that support engineers in tasks like storage and management of models, model checking, model verification or model transformation also grows. The latter is a special problem of the field of MDSD and consists, basically, of creating models automatically out of other models. This is possible because different models represent intersecting parts of the system under construction. One example of such a situation is the transformation of a class diagram into source-code or the compilation of source-code into machine-code.

Numerous approaches for the model transformation problem have been proposed by academy and industry. One of such approaches is the so-called operational approach, which focuses on the description of transformations either through imperative general-purpose languages, like Java, or domain-specific languages, like QVT-O \cite{omg2008meta}. Another one is the so-called relational approach, which focuses on the specification of transformations by means of a declarative language or formalism that embodies the relations between the elements of the different models to be transformed. Examples for this approach include QVT-R \cite{omg2008meta}, ATL \cite{jouault2006atl}, and the graph grammar approach \cite{ehrig1999handbook}, which utilizes the theories of graphs and formal languages to formalize models and describe relations between them. A specialization of the graph grammar formalism is the triple graph grammar (TGG) \cite{schurr1994specification}, which consists of specifying transformations by means of context-sensitive grammars of, so-called, triple graphs.

Triple graphs are composed of three graphs, the source and the target graphs, representing two models, and the correspondence graph that connects the source and the target through arrows. A triple graph can be used to express the relationships between two graphs by means of arrows between their vertices. More formally, a triple graph $G_s \ms{ms} G_c \mt{mt} G_t$ consists of three disjunct labeled graphs $G_s$, $G_c$, $G_t$, called source, correspondence, and target graphs, respectively, where the $G_s$ and $G_t$ contain elements of the two models of interest, and $G_c$ contains elements that connect $G_s$ and $G_t$ via two partial mappings $ms: G_c \pto G_s$ and $mt: G_c \pto G_t$ \cite{schurr1994specification}.

A TGG consists of a set of rules of the form $L \pro R$, where $L$ and $R$ are triple graphs. The application of a rule $L \pro R$ on a triple graph $G$ can be informally understood as the replacement of the occurrence of $L$ in $G$ by $R$. By this means, a TGG, analogously to classical string grammars, characterizes a language of triple graphs, that contains all triple graphs generated by consecutive rule applications starting from a special initial triple graph $Z_G$. In this sense, a TGG describes a language of pairs of graphs whose vertices have certain relationships.

For the context of model transformation, in which one is interested in defining a translator from a set of source models $\mathcal{G}$ to a set target models $\mathcal{T}$, a TGG can be used to describe the set of all correctly translated source models $G$ and their correspondent target models $T$, in form of a language of triple graphs. This approach is illustrated in Figure \ref{fig:general-approach-scheme}. Figure \ref{fig:detailed-approach-scheme} depicts the interplay between the sets of source and target models $\mathcal{G}$ and $\mathcal{T}$, the triple graphs $G \ms{} C \mt{} T$ and the triple graph grammar $TGG$.

\begin{figure}
	\begin{subfigure}[t]{0.5\textwidth}
		\include{misc/general-approach-scheme}
		\caption{General view of our approach}
		\label{fig:general-approach-scheme}
	\end{subfigure}
	\begin{subfigure}[t]{0.5\textwidth}
		\include{misc/detailed-approach-scheme}
		\caption{Detailed view of our approach}
		\label{fig:detailed-approach-scheme}
	\end{subfigure}
	\caption{Graphical illustration of our approach of using triple graphs and triple graph grammars as descriptors of model transformations}
\end{figure}

Despite the various positive aspects of TGG, like a well-founded theory and a reasonable tool support \cite{anjorin201620}, we have identified, that for some scenarios, a transformation described with TGG results in a grammar that is too big and difficult to comprehend. We judge, this downside stems from the absence of the concept of non-terminal symbols in the TGG formalism. This concept allows, in the theory of formal languages, for a very effective representation of abstract entities, what, in turn, makes grammars more comprehensible and easier to build. Moreover, it enables the Chomsky hierarchical classification of grammars \cite{chomsky1959}, that assigns different theoretical characteristics (e.g. generative power, parsing complexity) to different classes. Such classification has paved the way for the implementation of efficient parsers for specific classes of grammars, as well as, efficient compiler generators for programming languages.

We expect a TGG formalism that describes model transformations in a more compact manner and that makes it possible to encode abstract concepts efficiently through non-terminal symbols to be more comprehensible and to make model transformations easier to be constructed, verified and validated.

Hence, motivated by this benefit, the main objective of this thesis is to provide a novel formalism that redefines standard triple graph grammars and introduces the notion of non-terminal symbols to create a context-free triple graph grammar formalism. In particular, we also aim at reviewing key aspects of the current state-of-the-art, like the parsing of graph grammars; at discussing some theoretical and practical aspects of our new TGG formalism; and at demonstrating how it can be used for the solving of the model transformation problem.

In order to build our new TGG formalism, we mix an already established graph grammar technique that supports non-terminal symbols called \emph{graph grammar with neighborhood-controlled embedding} (NCE graph grammar) \cite{janssens1982graph} and the standard definition of TGG \cite{schurr1994specification} and name it NCE TGG. A NCE TGG consists of a set of rules of the form $A \pro R$, where $A$ is a symbol and $R$ is a triple graph. The application of a rule $A \pro R$ on a triple graph $G$ can be informally understood as the replacement of the occurrence of a vertex labeled with $A$ in $G$ by $R$. As in the standard TGG, a NCE TGG also characterizes a language of triple graphs holding all correctly transformed source and target graphs.

In order to demonstrate the application of our approach, we formalize the model transformation problem and show, supported by theoretical results, that a NCE TGG can be used to specify model transformations, which are then executed by our transformation algorithm. To enhance the generative power of our basic version of NCE TGG, we extend it with a mechanism of application conditions, called PAC NCE TGG, that allows us to study our proposal in more practical scenarios and for which we also develop a parsing and a transformation algorithm. The challenges and problems of a concrete implementation of such algorithms are also discussed and a case study containing an analysis in depth of two instances of the model transformation problem specified with NCE TGG and PAC NCE TGG is thereupon put forward.

Lastly, for the purpose of evaluating the usability of our proposal, we compare PAC NCE TGG against the standard TGG by measuring the size of 5 model transformations specified with both formalisms. To assess the performance of our implemented transformer, we execute it on the same model transformation specifications for several models with different sizes and report the results.

In summary, our proposed PAC NCE TGG formalism outperforms the standard TGG in one of the 5 evaluated cases with a specification almost one order of magnitude smaller, and is able to describe one model transformation that could not be described with the standard TGG. Moreover, in average, our approach produces smaller grammars. Negatively, PAC NCE TGG is outperformed by standard TGG in the other 3 evaluated cases and our implementation is considerably slower than the cutting edge TGG transformer eMoflon \cite{leblebici2014developing}. Nonetheless, we believe that the outcomes of this thesis are relevant for the current state of research in the field of MDSD and we judge that it contributes positively for the state-of-the-art.

The remainder of this thesis is as follows, in Chapter \ref{ch:RelatedWorks} we present a literary review of research works related to this thesis with a special focus on the topic of graph grammars with non-terminal symbols; in Chapter \ref{ch:TheoreticalReview} we provide the theoretical background necessary for the definition of the NCE TGG formalism; in Chapter \ref{ch:ModelTransformation} we present our argumentation of how NCE TGG solves the model transformation problem and a transformation algorithm; in Chapter \ref{ch:PacExtension} we extend NCE TGG by adding application conditions and demonstrate how the parsing and transformation works for this extension; in Chapter \ref{ch:Implementation} we discuss the details and open challenges of our implemented transformer; in Chapter \ref{ch:CaseStudy} two representative examples for specifications of model transformations with NCE TGG and PAC NCE TGG are analyzed in depth aiming for the practical application of our proposal; in Chapter \ref{ch:Evaluation} an experimental evaluation of usability and performance is exposed; and, finally, in Chapter \ref{ch:Conclusion} we conclude our exposition with a summary and an outlook about this work.
