%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CASE STUDY %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In this chapter, we take two examples of transformations specified with BNCE TGG and study them in depth, namely the already briefly introduced \emph{Pseudocode2Controlflow} transformation and the \emph{Class2Database} transformation. These two transformations are specially relevant for the practical application of our approach and embody well the main aspects of our presented theoretical framework. For each transformation specification, we try to convey the intuition behind each grammar rule and to make it clearer how the parsing and the transformation algorithms work by means of example derivations.

%%%%%%%%%%%%%%%%% Pseudocode2Controlflow %%%%%%%%%%%%%%%%%

For the first case study, consider the \emph{Pseudocode2Controlflow} transformation specification from Example \ref{ex:pseudocode2controlflow}. This transformation is encoded through the BNCE TGG $TGG = (\{S, A, p, a, i, w, g, b, c, f, x, n, l, r, pg, ac, ib, wb\}, \{p, a, i, w, g, b, c, f, x,$ $ n, l, r, pg, ac, ib, wb\}, S, P)$, where $P = \{r_i \st 0 \le i \le 5\}$ is denoted by\\
\input{examples/pseudocode2controlflow-tgg}

\noindent
with $\sigma_0 = \emptyset$, $\sigma_1(s_{11}) = \sigma_2(s_{21}) = \sigma_3(s_{31}) = \sigma_4(s_{41}) =\sigma_5(s_{51}) = \{ (f,p), (x,a), $ $(x,i), (x,w), (p,i), (n,i), (l,w), (f,w) \}$ and $\tau_1(t_{11}) = \tau_2(t_{21}) = \tau_3(t_{31}) = \tau_4(t_{41}) $ $= \tau_5(t_{51}) = \{ (r,g), (x,c), (x,b), (p,b), (n,b)\}$ being the complete definition of the source and target embedding functions of the rules $r_0$ to $r_5$, respectively.

\paragraph*{Rules. } The rule $r_0$ is responsible for creating the only $p$ and $g$ vertices of each triple graph in $L(TGG)$. This is the only rule that can transform the start symbol $S$ into something else and thus the rule that is always applied first in any derivation for triple graphs in $L(TGG)$. One could say that $r_0$ encodes the fact that any \emph{Pseudocode} graph consists of a $p$ (i.e. a program) containing an $A$ (i.e. an statement) and a \emph{Controlflow} graph consists of a $g$ (i.e. a graph) containing an $A$ (i.e. a basic block). The different possibilities of what an $A$ can be is in turn encoded by the different rules $r_1$, $r_2$, $r_3$, $r_4$, $r_5$, and $r_6$.

Through $r_1$ can an $A$ be transformed into an $a$ (i.e. an action) in the \emph{Pseudocode} graph and into an $c$ (i.e. a command) in the \emph{Controlflow} graph, both followed by another $A$. Analogously, through $r_2$ can $A$ become a $i$ (i.e. an if) and a $b$ (i.e. a branch) both with positive and negative branches, which are also $A$s, followed by another $A$. $r_3$ transforms an $A$ into an $w$ (i.e. a while) and a $b$ without further follow-up vertices except by an $A$ through the edge $x$, that is, $r_3$ can produce empty loops. $r_5$ and $r_4$, on the contrary, produce, respectively, a loop with one internal action/ command or with more than one internal statement/ basic block, represented by an $A$ that must be followed by an $a$/ $c$. Thereby, the $f$-labeled edge indicates the first statement in a loop and the $l$-labeled edge indicates the last action in the loop. We require the last element to be an action so that we can assure that it has no follow-ups. Lastly, $r_6$ allows an $A$ to be transformed into an empty graph, which has the effect of removing $A$ and makes it possible for a derivation to stop.

\paragraph*{Derivation. } In order to obtain a more concrete understanding on how the rules in $P$ work, we provide in the following the only derivation in $TGG$ for the triple graph $TG$ from Example \ref{ex:pseudocode2controlflow}. By investigating this derivation, it should be clear how the BNCE TGG mechanism works. It starts by the start triple graph $\startTG{TGG}$ and apply consecutively rules from $P$ to produce finally the goal triple graph.

\input{examples/pseudocode2controlflow-der}

\paragraph*{Transformation. } The transformation procedure consists, as already expound in Chapters \ref{ch:ModelTransformation}, \ref{ch:PacExtension} and \ref{ch:Implementation}, of the parsing of the input graph and the production of the triple graph. The goal of the parsing is to find the parsing tree correspondent to a derivation $D$ for the input as fast as possible. This search is efficiently performed when the set of found derivation steps contains only the ones in $D$. In Algorithm \ref{alg:parse} this is achieved when the set $bup$ grows minimally, that is, it is enlarged only with the zone vertices corresponding to the derivation steps in $D$.

To illustrate this optimal growth for Example \ref{ex:pseudocode2controlflow}, we construct the minimal final value for $bup$, by adding new subsets to its initial value $bup = \{ (p,\{v_0\}), (i,\{v_1\}), (a,\{v_2\}), (a,\{v_3\}), (w,\{v_4\}), (a,\{v_5\}), (a,\{v_6\}), (a,\{v_7\}) \}$. This construction is as follows,
\begin{align}
	\label{eq:bup_p2c_empty}
	bup \gets bup & \cup \{ (A, \{\}) \} \\
	\label{eq:bup_p2c_loop}
	& \cup \{ (A,\{v_7\}) \} \cup \{ (A,\{v_5\}) \} \cup \{ (A,\{v_4,v_5,v_6,v_7\}) \} \cup \{ (A,\{v_2\}) \} \\
	\label{eq:bup_p2c_if}
	& \cup \{ (A,\{v_3,v_4,v_5,v_6,v_7\}) \} \cup \{ (A, \{v_1,v_2,v_3,v_4,v_5,v_6,v_7\}) \} \\
	\label{eq:bup_p2c_S}
	& \cup \{ (S, \{v_0,v_1,v_2,v_3,v_4,v_5,v_6,v_7\}) \}
\end{align}

Through Equation \ref{eq:bup_p2c_empty} $bup$ receives the zone vertex $(A, \{\})$ because $A$ produces an empty graph through rule $r_6$. Through Equation \ref{eq:bup_p2c_loop} $bup$ is enlarged with those zone vertices stemming from derivations steps $\tderiv{r_1}{s_9,c_9,t_9}{}$, $\tderiv{r_1}{s_7,c_7,t_7}{}$, $\tderiv{r_4}{s_6,c_6,t_6}{}$, $\tderiv{r_1}{s_3,c_3,t_3}{}$. Lastly, Equation \ref{eq:bup_p2c_loop} enlarges $bup$ with those zone vertices stemming from derivations steps $\tderiv{r_1}{s_5,c_5,t_5}{}$, $\tderiv{r_2}{s_1,c_1,t_1}{}$ and Equation \ref{eq:bup_p2c_S} adds the final zone vertex $(S, V_{S_{TG}})$ because of derivation step $\tderiv{r_0}{s_0,c_0,t_0}{}$.

Although the optimal search course with a minimal final value for $bup$ is desired, it is not always achieved by our implementation, despite the several heuristics presented in Chapter \ref{ch:Implementation}. For instance, a naive implementation could end up adding the zone vertices $(A,\{v_6\})$ or $(A,\{v_4,v_5,v_6\}) $ to $bup$, because rules $r_1$ and $r_4$ allow it, even though they do not contribute to the final parsing tree. In other words, not all found derivations and added zone vertices are useful for finding the solution of the parsing problem, instead they even lead to useless exploration of the search space. Indeed, this is a negative aspect of our implementation, for determinism is not guaranteed and such useless computations may affect considerably the runtime of the parser. We believe that a better handling of how empty productions are used and a formalism where the direction of the edges played a bigger role by the embedding could improve our mechanism.

%%%%%%%%%%%%%%%%% Class2Database %%%%%%%%%%%%%%%%%

For the second case study, consider the \emph{Class2Database} transformation specification, which specifies all triple graphs holding correctly transformed class diagrams and database diagrams. Class diagrams are very often used for modelling of object-oriented information systems and database diagrams are used to depict database schemes. For simplicity purposes, we simplify considerably such diagrams. Here, class diagrams are graphs containing exactly one $cd$-labeled vertex that represents the \emph{class diagram} and that is connected with all $c$-labeled and $a$-labeled vertices that represent \emph{classes} and \emph{associations} through edges $\kappa$ and $\alpha$, respectively. An \emph{association} is necessarily connected to a source and a target \emph{class} through the edges $\zeta$ and $\psi$, respectively. Additionally, a \emph{class} may have zero ore more \emph{attributes} represented by $at$-labeled vertices connected to its \emph{class} through a $\beta$-labeled edge. A database diagram is a graph containing exactly one $db$-labeled vertex that represents the \emph{database} and is connected through $\pi$-labeled edges to all $t$-labeled vertices, which represent \emph{tables}. A \emph{table} may have one or more \emph{columns} connected to its tables through $\gamma$ edges. A \emph{column} can additionally reference an extra \emph{table} through a $\delta$ edge.

The \emph{Class2Database} transformation is encoded through the BNCE TGG $CD = (\{S, C, AT, SA, A, cd, c, at, a, db, t, co, dd, tc, ct, ac, \kappa, \alpha, \zeta, \psi, \beta, \pi, \gamma, \delta\}, \{cd, c, at, a, $ $ db, t, co, dd, tc, ct, ac, \kappa, \alpha, \zeta, \psi, \beta, \pi, \gamma, \delta\}, S, P)$, where $P = \{r_i \st 0 \le i \le 8\}$ is denoted by\\
\input{examples/class2database-tgg}

\noindent
with $\sigma_0 = \sigma_2 = \sigma_4 = \sigma_6 = \sigma_8 = \emptyset$, $\sigma_1(s_{10}) = \{(\kappa,cd),(\psi,a)\}$, $\sigma_1(s_{12}) = \{(\kappa,cd),(\alpha, cd)\}$, $\sigma_1(s_{11}) = \sigma_1(s_{13}) =\{(\alpha, cd)\}$, $\sigma_3(s_{30}) = \sigma_3(s_{31}) = \{(\beta,c)\}$, $\sigma_5(s_{50}) = \sigma_5(s_{51}) = \{(\zeta,c),(\psi,c),(\alpha,cd)\}$, $\sigma_7(s_{70}) = \sigma_7(s_{71}) = \{(\zeta,c),(\alpha,cd)\}$, $\sigma_7(s_{72}) = \{(\kappa,cd),(\zeta,a),(\psi,a),(\beta,at)\}$ being the complete definition of the source embedding functions and $\tau_0 = \tau_2 = \tau_4 = \tau_6 = \tau_8 = \emptyset$, $\tau_1(t_{10}) = \{(\pi,db),(\delta,co)\}$, $\tau_1(t_{12}) = \{(\pi,db)\}$, $\tau_3(t_{30}) = \tau_3(t_{31}) = \{(\gamma,t)\}$, $\tau_5(t_{50}) = \tau_5(t_{51}) = \{(\gamma,t),(\delta,t)\}$, $\tau_7(t_{70}) = \tau_7(t_{71}) = \{(\gamma,t)\}$, $\tau_7(t_{72}) = \{(\pi,db),(\delta,co),(\gamma,co)\}$ being the complete definition of the target embedding functions of the rules $r_0$ to $r_8$, respectively.

\paragraph*{Rules. } Rule $r_0$ is responsible for guaranteeing that every triple graph in $L(CD)$ has exactly one $cd$-labeled and one $db$-labeled vertex in the source and target graphs, respectively. Rule $r_1$ is responsible for creating each $c$/ $t$ vertex of any triple graph, which is connected to three nonterminal vertices $AT$(representing its attributes/ columns), $A$ (representing its associations/ references) and $SA$ (representing its self associations/ references). The $C$-labeled vertices allow for a triple graph to have more than one class/ table. Rule $r_3$ produces all $at$/ $co$ vertices of a class. The $AT$ vertex in this rule works for allowing a class/ table to have more than one attribute/ column. Rule $r_5$ produces, analogously, $a$-labeled vertices representing associations whose source and target are the same class in the source graph and $co$-labeled vertices representing columns that reference the same table to which they belong in the target graph. 

Rule $r_7$ create all associations between different classes in the source graph and all columns that reference not its owner table in the target graph. Thereby, it is important to notice that the $c$ and $t$-labeled vertices are PAC, what means that they are not produced by $r_7$, but they work as prerequisites for $r_7$ to be applied. That is, an association can only be created if it has a target class---represented by the $c$-labeled PAC vertex, which is resolved to a concrete vertex by a resolution step. Notice also that the existence of a source association is guaranteed by the $\zeta$-labeled edge from $A$ to $c$ in $r_1$. In this rule, the $c$-labeled vertex could not be a common (i.e. a non-PAC) vertex, because it would imply in the creation of a new class for each association, what in turn would not allow a class to have more than one incoming association. One could think of the PAC mechanism as a way to make a rule refer to vertices created by another rules before or after its application in a derivation. Insofar, we judge that this feature is a very powerful tool for the enhancement of the BNCE formalism.

Lastly, rules $r_2$, $r_4$, $r_6$, and $r_8$ allow the vertices labeled with the symbols $C$, $AT$, $SA$, and $A$ to be removed from a triple graph. Here, we highlight the practicality of such empty productions, for they allow to denote not only the optionality of a concept in a triple graph but also the termination of a recursive definition.

\paragraph*{Derivation. } In the following, we present an example of a derivation with PAC of a triple graph that belongs to the language of the triple graph grammar $CD$, introduced above. Notice that this is not the only possible derivation for the given triple graph, for the derivation steps could be rearranged in other order. Therefore, the grammar $CD$ is ambiguous. Notice also that, for a matter of space, we do not draw all the graphs in the derivation, instead we write $G_0$, $G_1$, $G_2$, $G_3$, and $G_4$ for some. The derivation should still be clear for the careful reader.

\input{examples/class2database-der}

\paragraph*{Transformation. } As already pointed out, the parsing phase of the transformation consists of growing the $bup$ until the final zone vertex containing all vertices of the input graph is obtained. A minimal $bup$ set at the end of the parsing of the input graph derived previously is constructed in the sequel from the initial value $bup = \{ (cd,\{v_0\}), (c,\{v_1\}), (a,\{v_2\}), (a,\{v_3\}), (c,\{v_4\}) \}$
\begin{align}
	\label{eq:bup_c2d_empty}
	bup \gets & bup \cup \{ (C, \{\}, \{\}),(AT, \{\}, \{\}),(SA, \{\}, \{\}),(A, \{\}, \{\}) \} \\
	\label{eq:bup_c2d_vs}
	& \cup \{ (C,\{v_4\}, \{\}) \} \cup \{ (SA,\{v_2\}, \{\}) \} \\
	\label{eq:bup_c2d_pac}
	& \cup \{ (A,\{v_3\}, \{v_4\}) \} \\
	\label{eq:bup_c2d_end}
	& \cup \{ (C,\{v_1,v_2,v_3,v_4\}, \{v_4\}) \} \cup \{ (S,\{v_0,v_1,v_2,v_3,v_4\}, \{v_4\}) \}
\end{align}

Through Equation \ref{eq:bup_c2d_empty} $bup$ receives the zone vertex correspondent to the rules that generate an empty graph $r_2$, $r_4$, $r_6$, and $r_8$, respectively. Through Equation \ref{eq:bup_c2d_vs} $bup$ is enlarged with those zone vertices stemming from derivations steps $\tderivpac{r_1}{s_7,c_7,t_7}{}{}$, $\tderivpac{r_5}{s_3,c_3,t_3}{}{}$. Then, Equation \ref{eq:bup_c2d_pac} enlarges $bup$ with the zone vertex stemming from derivation step $\tderivpac{r_7}{s_5,c_5,t_5}{\{p\},\{q\}}{}$. Notice that this zone vertex holds the vertex $v_4$ as a PAC vertex, which is used then later by the production phase of the transformation to resolve this PAC. Finally, Equation \ref{eq:bup_c2d_end} adds the last zone vertices because of derivation steps $\tderivpac{r_1}{s_1,c_1,t_1}{}{}$ and $\tderivpac{r_0}{s_0,c_0,t_0}{}{}$.

Differently from the first case study, this case study makes use of the PAC mechanism. Thus, its production phase in the transformation procedure occurs in a two-pass fashion, as expounded in Chapter \ref{ch:Implementation}. In the first pass, the rule of each derivation step is applied on the triple graph being constructed and PAC vertices are created (in the example, vertices $p$ and $q$). Because the zone vertices contain the information about the actual vertex in which the PAC vertices should be resolved, resolution steps according to this informations are created correctly, such that, in the second pass, the PAC vertices $p$ and $q$ are resolved into $v_4$ and $w_4$.

