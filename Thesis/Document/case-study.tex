%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CASE STUDY %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In this chapter, we take two examples of transformations specified with BNCE TGG and study them in depth, namely the already briefly introduced \emph{Pseudocode2Controlflow} transformation and the \emph{Class2Database} transformation. These two transformations are specially relevant for the practical application of our approach and embody well the main aspects of our presented theoretical framework. For each transformation specification, we try to convey the intuition behind each grammar rule and to make it clearer how the parsing and the transformation algorithms work by means of example derivations.

For the first case study, consider the \emph{Pseudocode2Controlflow} transformation specification from Example \ref{ex:pseudocode2controlflow}. This transformation is encoded through the BNCE TGG $TGG = (\{S, A, p, a, i, w, g, b, c, f, x, n, l, r, pg, ac, ib, wb\}, \{p, a, i, w, g, b, c, f, x,$ $ n, l, r, pg, ac, ib, wb\}, S, P)$, where $P = \{r_i \st 0 \le i \le 5\}$ is denoted by\\
\input{examples/pseudocode2controlflow-tgg}

\noindent
with $\sigma_0 = \emptyset$, $\sigma_1(s_{11}) = \sigma_2(s_{21}) = \sigma_3(s_{31}) = \sigma_4(s_{41}) =\sigma_5(s_{51}) = \{ (f,p), (x,a), $ $(x,i), (x,w), (p,i), (n,i), (l,w), (f,w) \}$ and $\tau_1(t_{11}) = \tau_2(t_{21}) = \tau_3(t_{31}) = \tau_4(t_{41}) $ $= \tau_5(t_{51}) = \{ (r,g), (x,c), (x,b), (p,b), (n,b)\}$ being the complete definition of the source and target embedding functions of the rules $r_0$ to $r_5$, respectively.

\paragraph*{Rules. } The rule $r_0$ is responsible for creating the only $p$ and $g$ vertices of each triple graph in $L(TGG)$. This is the only rule that can transform the start symbol $S$ into something else and thus the rule that is always applied first in any derivation for triple graphs in $L(TGG)$. One could say that $r_0$ encodes the fact that any \emph{Pseudocode} graph consists of a $p$ (i.e. a program) containing an $A$ (i.e. an statement) and a \emph{Controlflow} graph consists of a $g$ (i.e. a graph) containing an $A$ (i.e. a basic block). The different possibilities of what an $A$ can be is in turn encoded by the different rules $r_1$, $r_2$, $r_3$, $r_4$, $r_5$, and $r_6$.

Through $r_1$ can an $A$ be transformed into an $a$ (i.e. an action) in the \emph{Pseudocode} graph and into an $c$ (i.e. a command) in the \emph{Controlflow} graph, both followed by another $A$. Analogously, through $r_2$ can $A$ become a $i$ (i.e. an if) and a $b$ (i.e. a branch) both with positive and negative branches, which are also $A$s, followed by another $A$. $r_3$ transforms an $A$ into an $w$ (i.e. a while) and a $b$ without further follow-up vertices except by an $A$ through the edge $x$, that is, $r_3$ can produce empty loops. $r_5$ and $r_4$, on the contrary, produce, respectively, a loop with one internal action/ command or with more than one internal statement/ basic block, represented by an $A$ that must be followed by an $a$/ $c$. Thereby, the $f$-labeled edge indicates the first statement in a loop and the $l$-labeled edge indicates the last action in the loop. We require the last element to be an action so that we can assure that it has no follow-ups. Lastly, $r_6$ allows an $A$ to be transformed into an empty graph, which has the effect of removing $A$ and makes it possible for a derivation to stop.

\paragraph*{Derivation. } In order to obtain a more concrete understanding on how the rules in $P$ work, we provide in the following the only derivation in $TGG$ for the triple graph $TG$ from Example \ref{ex:pseudocode2controlflow}. By investigating this derivation, it should be clear how the BNCE TGG mechanism works. It starts by the start triple graph $\startTG{TGG}$ and apply consecutively rules from $P$ to produce finally the goal triple graph.

\input{examples/pseudocode2controlflow-der}

\paragraph*{Transformation. } The transformation procedure consists, as already expound in Chapters \label{ch:ModelTransformation} \label{ch:PacExtension} and \label{ch:Implementation}, of the parsing of the input graph and the production of the triple graph. The goal of the parsing is to find the parsing tree correspondent to a derivation $D$ for the input as fast as possible. This search is efficiently performed when the set of found derivation steps contains only the ones in $D$. In Algorithm \ref{alg:parsepac} this is achieved when the set $bup$ grows minimally, that is, it is enlarged only with the zone vertices corresponding to the derivation steps in $D$.

In Example \ref{ex:pseudocode2controlflow} this optimal growth of $bup$ would be...

\input{examples/class2database-tgg}
